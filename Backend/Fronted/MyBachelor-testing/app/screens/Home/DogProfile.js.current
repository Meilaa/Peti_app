import React, { useState, useEffect, useMemo } from 'react';
import { View, Text, StyleSheet, Image, TouchableOpacity, Modal, TextInput, ActivityIndicator, KeyboardAvoidingView, ScrollView, Platform, Alert, Switch } from 'react-native';
import { useRouter } from 'expo-router';
import colors from '../../constants/colors';
import DogImage from '../../../assets/images/dog_pics.png';
import FontAwesome6 from '@expo/vector-icons/FontAwesome6';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';
import environments from '../../constants/enviroments';
import AsyncStorage from '@react-native-async-storage/async-storage';
import moment from 'moment';
import { Picker } from '@react-native-picker/picker';

const DogProfile = () => {
  const router = useRouter();
  const [modalVisible, setModalVisible] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [animals, setAnimals] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [newProfile, setNewProfile] = useState({});
  const [loading, setLoading] = useState(true);
  const [confirmDelete, setConfirmDelete] = useState(false);
  const [trackerId, setTrackerId] = useState(''); // New state for tracker ID
  const [temperamentModalVisible, setTemperamentModalVisible] = useState(false);
  const [selectedTemperament, setSelectedTemperament] = useState('neutral');

  const [trackerModalVisible, setTrackerModalVisible] = useState(false);
  const [dogProfileModalVisible, setDogProfileModalVisible] = useState(false);
  const [createdDevice, setCreatedDevice] = useState(null); // Store created device after adding tracker

  // Add the tempermanetUpdateStatus to component state
  const [temperamentUpdateStatus, setTemperamentUpdateStatus] = useState(null);

  // Add this state variable at the top of the component with other state declarations
  const [recentlyChanged, setRecentlyChanged] = useState(false);

  const [isLost, setIsLost] = useState(false);
  const [lostModalVisible, setLostModalVisible] = useState(false);
  const [pendingLostUpdate, setPendingLostUpdate] = useState(false);

  // Add the missing editModalVisible state variable near the top with other state variables
  const [editModalVisible, setEditModalVisible] = useState(false);

  // Add missing edit form state variables
  const [editedName, setEditedName] = useState('');
  const [editedGender, setEditedGender] = useState('');
  const [editedBreed, setEditedBreed] = useState('');
  const [editedAge, setEditedAge] = useState('');
  const [editedHeight, setEditedHeight] = useState('');
  const [editedWeight, setEditedWeight] = useState('');

  // Fetch All Animals on Load
  useEffect(() => {
    const fetchAnimals = async () => {
      setLoading(true);
      try {
        const token = await AsyncStorage.getItem('authToken');
        const response = await fetch(`${environments.API_BASE_URL}/api/animals/`, {
          headers: { 'Authorization': `Bearer ${token}` },
        });
        const data = await response.json();
        if (response.ok) {
          data.forEach(animal => {
            animal.age = animal.age || 'N/A';  // Ensure age is present
          });
          setAnimals(data);   
        } else {
          setAnimals([]);
        }
      } catch (error) {
        console.error('Fetch error:', error);
      } finally {
        setLoading(false);
      }
    };
    fetchAnimals();
  }, []);

  // Get Current Animal
  const currentAnimal = animals[currentIndex] || null;

  // Get appropriate temperament info based on current animal
  const getTemperamentInfo = (temperament = 'neutral') => {
    switch (temperament) {
      case 'aggressive':
        return {
          label: 'Aggressive',
          color: colors.aggressive,
          backgroundColor: colors.aggressiveBackground || '#ffebee',
          icon: 'dog-side'
        };
      case 'friendly':
        return {
          label: 'Friendly',
          color: colors.friendly,
          backgroundColor: colors.friendlyBackground || '#e8f5e9',
          icon: 'dog'
        };
      default:
        return {
          label: 'Neutral',
          color: colors.neutral,
          backgroundColor: colors.neutralBackground || '#fff8e1',
          icon: 'dog-side'
        };
    }
  };

  // Add the missing renderTemperamentBadge function
  const renderTemperamentBadge = () => {
    if (!currentAnimal) return null;
    
    const temperamentInfo = getTemperamentInfo(currentAnimal.temperament);
    
    return (
      <View style={[
        styles.temperamentBadge, 
        { backgroundColor: temperamentInfo.backgroundColor },
        recentlyChanged && styles.recentlyChangedTemperament
      ]}>
        <MaterialCommunityIcons 
          name={temperamentInfo.icon} 
          size={24} 
          color={temperamentInfo.color} 
        />
        <Text style={[styles.temperamentBadgeText, { color: temperamentInfo.color }]}>
          {temperamentInfo.label}
        </Text>
      </View>
    );
  };

  // Modify the handleEditPress function to use setEditModalVisible instead of setModalVisible
  const handleEditPress = () => {
    if (!currentAnimal) return;
    
    // Set the individual edit form fields
    setEditedName(currentAnimal.name || '');
    setEditedGender(currentAnimal.gender || '');
    setEditedBreed(currentAnimal.breed || '');
    setEditedAge(currentAnimal.age ? String(currentAnimal.age) : '');
    setEditedHeight(currentAnimal.height ? String(currentAnimal.height) : '');
    setEditedWeight(currentAnimal.weight ? String(currentAnimal.weight) : '');
    
    // Still set newProfile for backward compatibility
    setNewProfile(currentAnimal);
    setIsEditing(true);
    setEditModalVisible(true);
  };

  const handleAddPress = () => {
    setTrackerId('');
    setNewProfile({ name: '', breed: '', age: '', gender: '', height: '', weight: '' });
    setCreatedDevice(null);
    setTrackerModalVisible(true);
  };

  const handleRegisterTracker = async () => {
    if (!trackerId) {
      alert('Please enter a valid Tracker ID');
      return;
    }
  
    try {
      const token = await AsyncStorage.getItem('authToken');
      const ownerId = await AsyncStorage.getItem('ownerId');
  
      const response = await fetch(`${environments.API_BASE_URL}/api/devices/addTracker`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          deviceName: `Device for ${trackerId}`,
          trackerID: trackerId,
          userId: ownerId,
        }),
      });
  
      // âœ… **Check if response is JSON**
      const responseText = await response.text();
      if (!response.ok) {
        console.error('Register Tracker Error:', responseText);
        alert(`Failed to register tracker: ${responseText}`);
        return;
      }
  
      const data = JSON.parse(responseText); // âœ… **Safe JSON parsing**
      console.log('Device Created:', data.device);
  
      setCreatedDevice(data.device); 
      setTrackerModalVisible(false);
      setDogProfileModalVisible(true);
    } catch (error) {
      console.error('Error during tracker registration:', error);
      alert('Failed to register tracker.');
    }
  };
  
  const linkAnimalToDevice = async (animalId, deviceId) => {
    try {
      const token = await AsyncStorage.getItem('authToken');
  
      const response = await fetch(`${environments.API_BASE_URL}/api/devices/linkAnimal`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          trackerObjectId: deviceId,  
          animalId: animalId,        
        }),
      });
  
      // âœ… **Check if response is JSON**
      const responseText = await response.text();
      if (!response.ok) {
        console.error('Link Animal Error:', responseText);
        alert(`Failed to link device with animal: ${responseText}`);
        return false;
      }
  
      const data = JSON.parse(responseText); // âœ… **Safe JSON parsing**
      console.log('Backend response (Link Animal):', data);
  
      return true;
    } catch (error) {
      console.error('Error linking device to animal:', error);
      alert('Error linking device to animal.');
      return false;
    }
  };
  

  const handleSaveDogProfile = async () => {
    if (!createdDevice) {
      alert('Device not found. Please register tracker again.');
      return;
    }
  
    if (!newProfile.name || !newProfile.breed || !newProfile.age || !newProfile.gender || !newProfile.height || !newProfile.weight) {
      alert('Please fill out all required fields.');
      return;
    }
  
    try {
      const token = await AsyncStorage.getItem('authToken');
      const ownerId = await AsyncStorage.getItem('ownerId');
  
      // Step 1: Create the animal profile
      const newAnimal = {
        ...newProfile,
        owner: ownerId,
        device: createdDevice._id, // Assign the device directly
        trackerID: createdDevice.deviceId,
        age: newProfile.age,
      };
  
      console.log('ðŸ¶ Payload being sent:', newAnimal);
  
      const createAnimalResponse = await fetch(`${environments.API_BASE_URL}/api/animals`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(newAnimal),
      });
  
      const createAnimalText = await createAnimalResponse.text(); // Get response as text first
      if (!createAnimalResponse.ok) {
        console.error('âŒ Create Animal Error:', createAnimalText);
        alert(`Failed to create animal: ${createAnimalText}`);
        return;
      }
  
      const createAnimalData = JSON.parse(createAnimalText); // Parse JSON safely
      console.log('âœ… Backend response (Create Animal):', createAnimalData);
  
      // Step 2: Update the device with the created animal ID
      const updateDeviceResponse = await fetch(`${environments.API_BASE_URL}/api/devices/${createdDevice._id}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ animal: createAnimalData.animal._id }),
      });
  
      const updateDeviceText = await updateDeviceResponse.text(); // Get response as text
      if (!updateDeviceResponse.ok) {
        console.error('âŒ Update Device Error:', updateDeviceText);
        alert(`Failed to update device: ${updateDeviceText}`);
        return;
      }
  
      const updateDeviceData = JSON.parse(updateDeviceText); // Parse JSON safely
      console.log('âœ… Backend response (Update Device):', updateDeviceData);
  
      // Step 3: Update the frontend state
      setAnimals([...animals, createAnimalData.animal]);
      setCurrentIndex(animals.length);
      setDogProfileModalVisible(false);
    } catch (error) {
      console.error('âŒ Error saving dog profile:', error);
      alert('Failed to save dog profile.');
    }
  };

  // Handle Delete Animal
  const handleDelete = async () => {
    try {
      if (!currentAnimal || !currentAnimal._id) {
        alert('No animal profile found.');
        return;
      }
  
      const token = await AsyncStorage.getItem('authToken');
      if (!token) {
        alert('Authentication error. Please log in again.');
        return;
      }
  
      // Step 1: Delete Device if it exists
      if (currentAnimal.device?._id) {
        const deviceId = currentAnimal.device._id;  // Only pass the string _id
      
        const deviceResponse = await fetch(`${environments.API_BASE_URL}/api/devices/${deviceId}`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`,
          },
        });
      
        if (!deviceResponse.ok) {
          const deviceError = await deviceResponse.json();
          console.error('Failed to delete device:', deviceError);
          alert(deviceError.message || 'Failed to delete associated device.');
          return;
        }
      
        console.log('Device deleted successfully');
      }
      
  
      // Step 2: Delete Animal
      const animalResponse = await fetch(`${environments.API_BASE_URL}/api/animals/${currentAnimal._id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
      });
  
      if (animalResponse.ok) {
        alert('Animal and associated device deleted successfully!');
        const updatedAnimals = animals.filter((animal) => animal._id !== currentAnimal._id);
        setAnimals(updatedAnimals);
        setCurrentIndex(updatedAnimals.length > 0 ? 0 : null);
        setConfirmDelete(false);
      } else {
        const animalError = await animalResponse.json();
        alert(animalError.message || 'Failed to delete animal.');
      }
  
    } catch (error) {
      console.error('Error deleting animal and device:', error);
      alert('Something went wrong. Please try again later.');
    }
  };
  const handleSaveEdit = async () => {
    try {
      // Show loading first
      setLoading(true);
      setEditModalVisible(false);
      
      const token = await AsyncStorage.getItem('authToken');
      if (!token) {
        throw new Error('No token found');
      }
      
      // Construct new profile data
      const updatedProfile = {
        name: editedName,
        gender: editedGender,
        breed: editedBreed,
        age: parseInt(editedAge) || 0,
        height: parseInt(editedHeight) || 0,
        weight: parseInt(editedWeight) || 0,
        isLost: isLost
      };
      
      console.log('Updating animal profile with data:', updatedProfile);
      
      // Send updated animal details
      const response = await fetch(`${environments.API_BASE_URL}/api/animals/${currentAnimal._id}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updatedProfile),
      });
      
      const responseData = await response.json();
      
      if (!response.ok) {
        throw new Error(responseData.message || `Failed to update animal: ${response.status}`);
      }
      
      // Update the animals array with the updated data
      const updatedAnimals = animals.map(animal => {
        if (animal._id === currentAnimal._id) {
          return {
            ...animal,
            ...updatedProfile
          };
        }
        return animal;
      });
      
      setAnimals(updatedAnimals);
      setRecentlyChanged(true);
      
      // Clear pending lost update flag since we've included it in the general update
      if (pendingLostUpdate) {
        setPendingLostUpdate(false);
        // Also remove from AsyncStorage pending updates
        try {
          const pendingUpdatesString = await AsyncStorage.getItem('pendingLostUpdates');
          if (pendingUpdatesString) {
            const pendingUpdates = JSON.parse(pendingUpdatesString);
            const filteredUpdates = pendingUpdates.filter(update => update.animalId !== currentAnimal._id);
            await AsyncStorage.setItem('pendingLostUpdates', JSON.stringify(filteredUpdates));
          }
        } catch (error) {
          console.error('Error clearing pending lost update:', error);
        }
      }
      
      Alert.alert('Success', 'Animal profile updated successfully');
    } catch (error) {
      console.error('Error updating animal:', error);
      
      // If the update failed, we still want to update the local UI
      // but mark the lost status as pending if it was changed
      const updatedAnimals = animals.map(animal => {
        if (animal._id === currentAnimal._id) {
          const animalUpdate = {
            ...animal,
            name: editedName,
            gender: editedGender,
            breed: editedBreed,
            age: parseInt(editedAge) || 0,
            height: parseInt(editedHeight) || 0,
            weight: parseInt(editedWeight) || 0,
            isLost: isLost,
          };
          
          // If the lost status is different from what's in the backend
          // mark it as pending
          if (animal.isLost !== isLost) {
            animalUpdate.pendingLostUpdate = true;
            setPendingLostUpdate(true);
            storePendingLostUpdate(animal._id, isLost);
          }
          
          return animalUpdate;
        }
        return animal;
      });
      
      setAnimals(updatedAnimals);
      setRecentlyChanged(true);
      
      Alert.alert('Error', 'Failed to update animal on server. Changes saved locally.');
    } finally {
      setLoading(false);
    }
  };
  
  // Handle Delete Confirmation
  const handleDeleteConfirm = () => {
    setConfirmDelete(true);
  };

  // Handle Cancel Deletion
  const handleDeleteCancel = () => {
    setConfirmDelete(false);
  };

  // Navigation Functions
  const handleNext = () => {
    if (currentIndex < animals.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  const handlePrev = () => {
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }
  };

  // Open Temperament Modal
  const handleTemperamentPress = () => {
    if (!currentAnimal) return;
    setSelectedTemperament(currentAnimal.temperament || 'neutral');
    setTemperamentModalVisible(true);
  };

  // Update the updateTemperament function to log detailed information 
  const updateTemperament = async (newTemperament) => {
    if (!currentAnimal || !currentAnimal._id) {
      Alert.alert("Error", "No animal selected");
      return;
    }

    console.log(`Updating temperament for animal: ${currentAnimal._id}, name: ${currentAnimal.name}, to: ${newTemperament}`);

    // Save temperament change in AsyncStorage immediately for local updates
    try {
      // Update temperament changes list for UI highlighting
      const storedChangesString = await AsyncStorage.getItem('temperamentChanges') || '[]';
      const storedChanges = JSON.parse(storedChangesString);
      
      // Add this change with timestamp
      const newChange = {
        animalId: currentAnimal._id,
        timestamp: Date.now(),
        temperament: newTemperament
      };
      
      // Filter out old changes for this animal and add the new one
      const updatedChanges = storedChanges
        .filter(change => change.animalId !== currentAnimal._id)
        .concat(newChange);
        
      // Only keep changes from the last 5 seconds
      const recentChanges = updatedChanges.filter(
        change => Date.now() - change.timestamp < 5000
      );
      
      console.log("Storing temperament change:", newChange);
      await AsyncStorage.setItem('temperamentChanges', JSON.stringify(recentChanges));
      
      // Update the animals array directly instead of using setCurrentAnimal
      const updatedAnimals = animals.map(animal => 
        animal._id === currentAnimal._id 
          ? { ...animal, temperament: newTemperament }
          : animal
      );
      
      // Update local state for immediate UI update
      setAnimals(updatedAnimals);
      // Close the modal after setting the state
      setTemperamentModalVisible(false);
      
      // Show feedback to user
      setTemperamentUpdateStatus({
        message: `${currentAnimal.name || currentAnimal.animalName}'s temperament updated to ${newTemperament}`,
        type: 'success'
      });
      
      // Verify the temperament change is in AsyncStorage
      const verifyStoredChanges = await AsyncStorage.getItem('temperamentChanges');
      console.log("Verified temperament changes in storage:", verifyStoredChanges);
      
      // Clear status after 3 seconds
      setTimeout(() => setTemperamentUpdateStatus(null), 3000);
    } catch (error) {
      console.error("Error saving temperament locally:", error);
    }

    // Server update with proper authentication
    try {
      // Get the authentication token
      const token = await AsyncStorage.getItem('authToken');
      if (!token) {
        throw new Error('No authentication token found');
      }

      const response = await fetch(`${environments.API_BASE_URL}/api/animals/${currentAnimal._id}/temperament`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}` // Add the authentication token
        },
        body: JSON.stringify({
          temperament: newTemperament
        }),
      });

      // Check if the response is ok
      if (!response.ok) {
        throw new Error(`Server responded with status: ${response.status}`);
      }

      // Try to parse JSON, but handle cases where the response might not be JSON
      let data;
      const contentType = response.headers.get("content-type");
      if (contentType && contentType.includes("application/json")) {
        data = await response.json();
      } else {
        const text = await response.text();
        data = { message: text };
      }

      console.log("Server update successful:", data);
    } catch (error) {
      console.error("Error updating temperament on server:", error);
      
      // Show user feedback about the server issue but reassure about local update
      Alert.alert(
        "Sync Issue",
        "Your change was saved locally but couldn't sync with the server. Will retry automatically.",
        [{ text: "OK" }]
      );
      
      // Schedule a retry in the background
      setTimeout(() => {
        retryTemperamentUpdate(currentAnimal._id, newTemperament);
      }, 10000); // Try again in 10 seconds
    }
  };

  // Update the retry function to include the token
  const retryTemperamentUpdate = async (animalId, temperament) => {
    try {
      // Get the authentication token
      const token = await AsyncStorage.getItem('authToken');
      if (!token) {
        console.error('No authentication token found for retry');
        return;
      }
      
      const response = await fetch(`${environments.API_BASE_URL}/api/animals/${animalId}/temperament`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}` // Add the authentication token
        },
        body: JSON.stringify({
          temperament: temperament
        }),
      });
      
      if (response.ok) {
        console.log("Retry successful for animal ID:", animalId);
      } else {
        console.error("Retry failed with status:", response.status);
        // Schedule another retry
        setTimeout(() => {
          retryTemperamentUpdate(animalId, temperament);
        }, 30000); // Try again in 30 seconds
      }
    } catch (error) {
      console.error("Error in retry attempt:", error);
    }
  };

  // Fix the useEffect for temperament changes
  useEffect(() => {
    // Create a flag to track component mount state
    let isMounted = true;
    
    // Only check when currentAnimal changes, not on every render
    const checkRecentChange = async () => {
      if (!isMounted || !currentAnimal) return;
      
      try {
        const storedChangesString = await AsyncStorage.getItem('temperamentChanges');
        if (storedChangesString) {
          const storedChanges = JSON.parse(storedChangesString);
          const isChanged = storedChanges.some(change => 
            change.animalId === currentAnimal._id ||
            change.animalId === currentAnimal.id
          );
          
          if (isChanged !== recentlyChanged) {
            setRecentlyChanged(isChanged);
          }
        }
      } catch (err) {
        console.error("Error checking recent changes:", err);
      }
    };
    
    // Run once on mount or when currentAnimal changes
    checkRecentChange();
    
    // Clean up function to prevent memory leaks
    return () => {
      isMounted = false;
    };
  }, [currentAnimal?._id]); // Only depend on the ID, not the entire object

  // Add a separate useEffect for lost status with proper dependency
  useEffect(() => {
    if (currentAnimal) {
      // Use the isLost property from the animal if it exists
      const animalIsLost = !!currentAnimal.isLost;
      
      // Only update state if it's different to avoid loops
      if (isLost !== animalIsLost) {
        setIsLost(animalIsLost);
      }
      
      const animalPendingUpdate = !!currentAnimal.pendingLostUpdate;
      if (pendingLostUpdate !== animalPendingUpdate) {
        setPendingLostUpdate(animalPendingUpdate);
      }
    }
  }, [currentAnimal?._id]); // Only depend on the ID, not the whole object

  // Modify the toggleLostStatus function to handle API errors better
  const toggleLostStatus = async (newLostStatus) => {
    try {
      // Immediately update UI for responsiveness
      setIsLost(newLostStatus);
      setPendingLostUpdate(true);
      
      // Update the current animal in the animals array for immediate UI update
      const updatedAnimals = animals.map(animal => 
        animal._id === currentAnimal._id 
          ? { ...animal, isLost: newLostStatus, pendingLostUpdate: true }
          : animal
      );
      setAnimals(updatedAnimals);
      
      // Try to update on the server
      const token = await AsyncStorage.getItem('authToken');
      if (!token) {
        throw new Error('No token found');
      }

      try {
        // Add timeout to prevent hanging
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('API request timeout')), 8000)
        );
        
        // First try the dedicated lost dog endpoint
        const fetchPromise = fetch(`${environments.API_BASE_URL}/api/animals/${currentAnimal._id}/lost`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ isLost: newLostStatus }),
        });
        
        // Race between the fetch and the timeout
        const response = await Promise.race([fetchPromise, timeoutPromise]);

        if (!response.ok) {
          // If endpoint doesn't exist (404), try the general update endpoint instead
          if (response.status === 404) {
            console.log('Lost dog API endpoint not found (404), trying general update endpoint');
            
            const generalUpdateResponse = await fetch(`${environments.API_BASE_URL}/api/animals/${currentAnimal._id}`, {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ 
                isLost: newLostStatus,
                // Include other fields to preserve them
                name: currentAnimal.name,
                gender: currentAnimal.gender,
                breed: currentAnimal.breed,
                age: currentAnimal.age,
                height: currentAnimal.height,
                weight: currentAnimal.weight
              }),
            });
            
            if (!generalUpdateResponse.ok) {
              throw new Error(`Failed to update with general endpoint: ${generalUpdateResponse.status}`);
            }
            
            // General update worked
            console.log(`Dog ${currentAnimal._id} lost status updated via general endpoint to: ${newLostStatus}`);
          } else {
            throw new Error(`Failed to update lost status: ${response.status}`);
          }
        } else {
          // Dedicated endpoint worked
          console.log(`Dog ${currentAnimal._id} lost status updated via dedicated endpoint to: ${newLostStatus}`);
        }
        
        // Update was successful via one of the endpoints
        setPendingLostUpdate(false);
        
        // Update the animals array with successful update
        const successfullyUpdatedAnimals = animals.map(animal => 
          animal._id === currentAnimal._id 
            ? { ...animal, isLost: newLostStatus, pendingLostUpdate: false }
            : animal
        );
        setAnimals(successfullyUpdatedAnimals);
        
        // Show success message
        Alert.alert(
          newLostStatus ? "Dog Marked as Lost" : "Dog Marked as Found",
          newLostStatus 
            ? "Other users will now be able to see this dog's location." 
            : "The dog has been marked as found.",
          [{ text: "OK" }]
        );
        
      } catch (apiError) {
        console.error('API Error updating lost dog status:', apiError);
        
        // Store change locally for later sync
        await storePendingLostUpdate(currentAnimal._id, newLostStatus);
        
        // Inform the user
        Alert.alert(
          "Offline Mode", 
          "Unable to connect to the server. Your change has been saved locally and will sync when connection is restored.",
          [{ text: "OK" }]
        );
      }
    } catch (error) {
      console.error('Error updating lost dog status:', error);
      
      // Keep the UI updated even if there's an error
      Alert.alert(
        "Update Saved Locally", 
        "We'll try to update the server when connection is available."
      );
    }
  };

  // Add function to store pending lost status updates
  const storePendingLostUpdate = async (animalId, isLost) => {
    try {
      // Get existing pending updates
      const pendingUpdatesString = await AsyncStorage.getItem('pendingLostUpdates');
      let pendingUpdates = pendingUpdatesString ? JSON.parse(pendingUpdatesString) : [];
      
      // Add new update (or update existing)
      const existingIndex = pendingUpdates.findIndex(update => update.animalId === animalId);
      if (existingIndex >= 0) {
        pendingUpdates[existingIndex] = { animalId, isLost, timestamp: Date.now() };
      } else {
        pendingUpdates.push({ animalId, isLost, timestamp: Date.now() });
      }
      
      // Store back in AsyncStorage
      await AsyncStorage.setItem('pendingLostUpdates', JSON.stringify(pendingUpdates));
      console.log(`Stored pending lost update for animal ${animalId}: ${isLost}`);
    } catch (error) {
      console.error('Error storing pending lost update:', error);
    }
  };

  // Get helper function to determine if lost dog feature should be shown
  const shouldShowLostFeature = () => {
    // Only show lost feature for aggressive dogs for safety reasons
    return currentAnimal && currentAnimal.temperament === 'aggressive';
  };

  // Fix the renderLostStatusSection function to avoid conditional rendering problems
  const renderLostStatusSection = () => {
    if (!currentAnimal || currentAnimal.temperament !== 'aggressive') {
      return null;
    }

    // Define status constants outside of the render cycle
    const lostStatusInfo = useMemo(() => {
      return isLost ? {
        label: 'Lost Dog',
        description: 'Dog\'s location visible to all users',
        buttonText: 'Mark as Found',
        color: colors.aggressive,
        icon: 'warning',
        action: () => setLostModalVisible(true)
      } : {
        label: 'Dog is Safe',
        description: 'Mark as lost if missing',
        buttonText: 'Mark as Lost',
        color: colors.darkGray,
        icon: 'check-circle',
        action: () => setLostModalVisible(true)
      };
    }, [isLost]); // Only recalculate when isLost changes

    return (
      <View style={styles.compactSection}>
        <Text style={styles.sectionTitle}>Lost Status</Text>
        <View style={[styles.lostStatusContainer, isLost && styles.lostStatusActiveContainer]}>
          <View style={styles.lostStatusContent}>
            <MaterialIcons name={lostStatusInfo.icon} size={20} color={lostStatusInfo.color} style={styles.lostStatusIcon} />
            <View style={styles.lostStatusTextContainer}>
              <Text style={[styles.lostStatusLabel, { color: lostStatusInfo.color }]}>
                {lostStatusInfo.label}
                {pendingLostUpdate && ' (Pending)'}
              </Text>
              <Text style={styles.lostStatusDescription}>{lostStatusInfo.description}</Text>
            </View>
          </View>
          <TouchableOpacity 
            style={[styles.lostStatusButton, isLost && styles.foundButton]} 
            onPress={lostStatusInfo.action}
          >
            <Text style={styles.lostStatusButtonText}>{lostStatusInfo.buttonText}</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  // Render the lost status modal
  const renderLostStatusModal = () => {
    return (
      <Modal
        visible={lostModalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setLostModalVisible(false)}
      >
        <View style={styles.modalBackground}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>
                {isLost ? 'Mark Dog as Found' : 'Mark Dog as Lost'}
              </Text>
              <TouchableOpacity 
                style={styles.closeButton} 
                onPress={() => setLostModalVisible(false)}
              >
                <MaterialIcons name="close" size={24} color={colors.darkGray} />
              </TouchableOpacity>
            </View>
            
            <View style={styles.lostModalBody}>
              <MaterialIcons 
                name={isLost ? "location-off" : "location-on"} 
                size={50} 
                color={isLost ? colors.success : colors.aggressive} 
                style={styles.lostModalIcon}
              />
              
              <Text style={styles.lostModalTitle}>
                {isLost 
                  ? `Mark ${currentAnimal?.name || 'your dog'} as Found?` 
                  : `Mark ${currentAnimal?.name || 'your dog'} as Lost?`}
              </Text>
              
              <Text style={styles.lostModalDescription}>
                {isLost 
                  ? "This will stop sharing your dog's location with other users." 
                  : "This will mark your dog as lost and share its location with all users. Only use this feature if your dog is actually lost."}
              </Text>
              
              {currentAnimal?.temperament !== 'aggressive' && !isLost && (
                <View style={styles.warningBox}>
                  <MaterialIcons name="warning" size={24} color={colors.warning} style={styles.warningIcon} />
                  <Text style={styles.warningText}>
                    Only aggressive dogs can be marked as lost for public safety tracking.
                  </Text>
                </View>
              )}
              
              <View style={styles.lostModalButtonsRow}>
                <TouchableOpacity 
                  style={[styles.lostModalButton, styles.lostModalCancelButton]} 
                  onPress={() => setLostModalVisible(false)}
                >
                  <Text style={styles.lostModalButtonText}>Cancel</Text>
                </TouchableOpacity>
                
                <TouchableOpacity 
                  style={[
                    styles.lostModalButton, 
                    isLost ? styles.lostModalFoundButton : styles.lostModalLostButton,
                    currentAnimal?.temperament !== 'aggressive' && !isLost && styles.lostModalDisabledButton
                  ]} 
                  onPress={() => {
                    if (currentAnimal?.temperament !== 'aggressive' && !isLost) {
                      Alert.alert(
                        "Not Allowed", 
                        "Only aggressive dogs can be marked as lost for public safety tracking. Please update the dog's temperament first.",
                        [{ text: "OK" }]
                      );
                      return;
                    }
                    toggleLostStatus(!isLost);
                    setLostModalVisible(false);
                  }}
                >
                  <Text style={styles.lostModalButtonText}>
                    {isLost ? "Mark as Found" : "Mark as Lost"}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </View>
      </Modal>
    );
  };

  // Completely replace the renderEditModal function
  const renderEditModal = () => {
    return (
      <Modal
        animationType="slide"
        transparent={true}
        visible={editModalVisible}
        onRequestClose={() => setEditModalVisible(false)}
      >
        <View style={styles.modalBackground}>
          <KeyboardAvoidingView
            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
            style={{ flex: 1, width: '100%', maxWidth: 500 }}
          >
            <View style={styles.editModalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Edit Dog Profile</Text>
                <TouchableOpacity onPress={() => setEditModalVisible(false)} style={styles.closeButton}>
                  <MaterialIcons name="close" size={24} color={colors.darkGray} />
                </TouchableOpacity>
              </View>
              
              <ScrollView style={{ flex: 1 }} contentContainerStyle={{ padding: 20 }}>
                <View style={styles.inputContainer}>
                  <Text style={styles.inputLabel}>Name</Text>
                  <TextInput
                    style={styles.input}
                    value={editedName}
                    onChangeText={setEditedName}
                    placeholder="Enter dog's name"
                  />
                </View>
                
                <View style={styles.inputContainer}>
                  <Text style={styles.inputLabel}>Gender</Text>
                  <TextInput
                    style={styles.input}
                    value={editedGender}
                    onChangeText={setEditedGender}
                    placeholder="Enter dog's gender"
                  />
                </View>
                
                <View style={styles.inputContainer}>
                  <Text style={styles.inputLabel}>Breed</Text>
                  <TextInput
                    style={styles.input}
                    value={editedBreed}
                    onChangeText={setEditedBreed}
                    placeholder="Enter dog's breed"
                  />
                </View>
                
                <View style={styles.inputContainer}>
                  <Text style={styles.inputLabel}>Age (years)</Text>
                  <TextInput
                    style={styles.input}
                    value={editedAge ? String(editedAge) : ''}
                    onChangeText={setEditedAge}
                    keyboardType="numeric"
                    placeholder="Enter dog's age"
                  />
                </View>
                
                <View style={styles.inputContainer}>
                  <Text style={styles.inputLabel}>Height (cm)</Text>
                  <TextInput
                    style={styles.input}
                    value={editedHeight ? String(editedHeight) : ''}
                    onChangeText={setEditedHeight}
                    keyboardType="numeric"
                    placeholder="Enter dog's height"
                  />
                </View>
                
                <View style={styles.inputContainer}>
                  <Text style={styles.inputLabel}>Weight (kg)</Text>
                  <TextInput
                    style={styles.input}
                    value={editedWeight ? String(editedWeight) : ''}
                    onChangeText={setEditedWeight}
                    keyboardType="numeric"
                    placeholder="Enter dog's weight"
                  />
                </View>
                
                {/* Add lost status toggle */}
                {currentAnimal?.temperament === 'aggressive' && (
                  <View style={styles.toggleContainer}>
                    <View style={styles.toggleLabelContainer}>
                      <MaterialIcons 
                        name={isLost ? "warning" : "check-circle"} 
                        size={24} 
                        color={isLost ? colors.aggressive : colors.success} 
                        style={styles.toggleIcon}
                      />
                      <Text style={styles.toggleLabel}>Mark as Lost Dog</Text>
                    </View>
                    <Switch
                      trackColor={{ false: colors.lightGray, true: colors.aggressive + '80' }}
                      thumbColor={isLost ? colors.aggressive : colors.white}
                      ios_backgroundColor={colors.lightGray}
                      onValueChange={(value) => setIsLost(value)}
                      value={isLost}
                    />
                  </View>
                )}
                
                {currentAnimal?.temperament !== 'aggressive' && (
                  <View style={styles.warningBoxSmall}>
                    <MaterialIcons name="info" size={20} color={colors.warning} />
                    <Text style={styles.warningTextSmall}>
                      Only aggressive dogs can be marked as lost for safety tracking.
                    </Text>
                  </View>
                )}
                
                {/* Add padding at the bottom for better scrolling */}
                <View style={{ height: 20 }} />
              </ScrollView>
              
              {/* Fixed button container outside of ScrollView */}
              <View style={styles.editButtonsContainer}>
                <TouchableOpacity style={styles.cancelButton} onPress={() => setEditModalVisible(false)}>
                  <Text style={styles.cancelButtonText}>Cancel</Text>
                </TouchableOpacity>
                <TouchableOpacity 
                  style={styles.saveButton} 
                  onPress={handleSaveEdit}
                  disabled={loading}
                >
                  {loading ? (
                    <ActivityIndicator size="small" color="#fff" />
                  ) : (
                    <Text style={styles.saveButtonText}>Save Changes</Text>
                  )}
                </TouchableOpacity>
              </View>
            </View>
          </KeyboardAvoidingView>
        </View>
      </Modal>
    );
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={colors.yellow} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <View style={styles.headerContainer}>
          <TouchableOpacity onPress={handlePrev} disabled={currentIndex === 0}>
            <MaterialIcons name="arrow-back-ios-new" size={20} color={currentIndex === 0 ? 'gray' : colors.yellow} />
          </TouchableOpacity>
          <View style={styles.imageContainer}>
            <Image source={DogImage} style={styles.profileImage} />
          </View>
          <TouchableOpacity onPress={handleNext} disabled={currentIndex >= animals.length - 1}>
            <MaterialIcons name="arrow-forward-ios" size={20} color={currentIndex >= animals.length - 1 ? 'gray' : colors.yellow} />
          </TouchableOpacity>
        </View>
        <Text style={styles.title}>{currentAnimal?.name || 'No Dog Found'}</Text>
        
        {/* Add temperament badge below the name */}
        {currentAnimal?.temperament && renderTemperamentBadge()}
      </View>

      {/* Buttons */}
      <View style={styles.buttonRow}>
        <View style={styles.buttonColumn}>
          <TouchableOpacity style={styles.button} onPress={handleAddPress}>
            <FontAwesome6 name="add" size={20} color={colors.white} />
          </TouchableOpacity>
          <Text style={styles.buttonText}>Add Dog</Text>
        </View>
        <View style={styles.buttonColumn}>
          <TouchableOpacity style={styles.button} onPress={handleEditPress}>
            <FontAwesome6 name="edit" size={18} color={colors.white} />
          </TouchableOpacity>
          <Text style={styles.buttonText}>Edit Profile</Text>
        </View>
        <View style={styles.buttonColumn}>
          <TouchableOpacity style={styles.button} onPress={handleDeleteConfirm}>
            <FontAwesome6 name="trash" size={20} color={colors.white} />
          </TouchableOpacity>
          <Text style={styles.buttonText}>Delete</Text>
        </View>
        <View style={styles.buttonColumn}>
          <TouchableOpacity 
            style={[
              styles.button, 
              currentAnimal?.temperament === 'aggressive' ? styles.aggressiveButton :
              currentAnimal?.temperament === 'friendly' ? styles.friendlyButton :
              styles.button
            ]} 
            onPress={handleTemperamentPress}>
            <MaterialCommunityIcons 
              name="dog-side" 
              size={20} 
              color={colors.white} 
            />
          </TouchableOpacity>
          <Text style={styles.buttonText}>Temperament</Text>
        </View>
      </View>

      {/* Profile Details */}
      {currentAnimal && (
        <View style={styles.profileDetails}>
          {["name", "breed", "age", "gender", "height", "weight"].map((field) => (
            <View style={styles.row} key={field}>
              <Text style={styles.label}>{field.charAt(0).toUpperCase() + field.slice(1)}</Text>
              <Text style={styles.value}>{currentAnimal[field] || 'N/A'}</Text>
            </View>
          ))}
          <View style={styles.row}>
            <Text style={styles.label}>Temperament</Text>
            <View style={{flexDirection: 'row', alignItems: 'center'}}>
              <View style={[styles.temperamentIndicator, 
                currentAnimal.temperament === 'aggressive' ? styles.aggressiveIndicator : 
                currentAnimal.temperament === 'friendly' ? styles.friendlyIndicator : 
                styles.neutralIndicator]} />
              <Text style={[
                styles.value,
                currentAnimal.temperament === 'aggressive' ? { color: colors.aggressive } :
                currentAnimal.temperament === 'friendly' ? { color: colors.friendly } :
                {}
              ]}>
                {currentAnimal.temperament ? 
                  currentAnimal.temperament.charAt(0).toUpperCase() + currentAnimal.temperament.slice(1) : 
                  'Neutral'}
              </Text>
            </View>
          </View>
        </View>
      )}

      {/* Temperament Modal with improved UI */}
      <Modal
        animationType="slide"
        transparent={true}
        visible={temperamentModalVisible}
        onRequestClose={() => setTemperamentModalVisible(false)}
      >
        <View style={styles.modalBackground}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Update Dog Temperament</Text>
              <TouchableOpacity onPress={() => setTemperamentModalVisible(false)}>
                <MaterialIcons name="close" size={24} color={colors.yellow} />
              </TouchableOpacity>
            </View>
            
            <Text style={styles.temperamentLabel}>Select your dog's temperament:</Text>
            
            <View style={styles.temperamentOptionsContainer}>
              <TouchableOpacity 
                style={[styles.temperamentOption, 
                  selectedTemperament === 'aggressive' && styles.selectedTemperament,
                  selectedTemperament === 'aggressive' && styles.selectedAggressiveOption
                ]} 
                onPress={() => setSelectedTemperament('aggressive')}
              >
                <MaterialCommunityIcons 
                  name="dog-side" 
                  size={30} 
                  color={selectedTemperament === 'aggressive' ? colors.white : colors.aggressive} 
                />
                <Text style={[styles.temperamentText, selectedTemperament === 'aggressive' && styles.selectedTemperamentText]}>
                  Aggressive
                </Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[styles.temperamentOption, 
                  selectedTemperament === 'neutral' && styles.selectedTemperament
                ]} 
                onPress={() => setSelectedTemperament('neutral')}
              >
                <MaterialCommunityIcons 
                  name="dog-side" 
                  size={30} 
                  color={selectedTemperament === 'neutral' ? colors.white : colors.neutral} 
                />
                <Text style={[styles.temperamentText, selectedTemperament === 'neutral' && styles.selectedTemperamentText]}>
                  Neutral
                </Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[styles.temperamentOption, 
                  selectedTemperament === 'friendly' && styles.selectedTemperament,
                  selectedTemperament === 'friendly' && styles.selectedFriendlyOption
                ]} 
                onPress={() => setSelectedTemperament('friendly')}
              >
                <MaterialCommunityIcons 
                  name="dog" 
                  size={30} 
                  color={selectedTemperament === 'friendly' ? colors.white : colors.friendly} 
                />
                <Text style={[styles.temperamentText, selectedTemperament === 'friendly' && styles.selectedTemperamentText]}>
                  Friendly
                </Text>
              </TouchableOpacity>
            </View>
            
            <TouchableOpacity 
              style={[
                styles.saveButton,
                selectedTemperament === 'aggressive' ? styles.aggressiveSaveButton :
                selectedTemperament === 'friendly' ? styles.friendlySaveButton :
                styles.saveButton
              ]} 
              onPress={() => updateTemperament(selectedTemperament)}
            >
              <Text style={styles.saveButtonText}>Save</Text>
            </TouchableOpacity>

            {/* Add this inside the temperament modal, before the closing View */}
            {temperamentUpdateStatus && (
              <View style={[
                styles.statusMessage, 
                { backgroundColor: temperamentUpdateStatus.type === 'success' ? '#4CAF50' : '#F44336' }
              ]}>
                <Text style={styles.statusMessageText}>{temperamentUpdateStatus.message}</Text>
              </View>
            )}
          </View>
        </View>
      </Modal>

      {/* Modal */}
      {/* tracker */}
      <Modal visible={trackerModalVisible} transparent animationType="slide">
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "height"}
          style={styles.modalBackground}
        >
          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            <View style={styles.modalContainer}>
              <Text style={styles.modalTitle}>Register Tracker</Text>
              <TextInput
                style={styles.input}
                placeholder="Tracker ID"
                value={trackerId}
                onChangeText={setTrackerId}
              />
              <View style={styles.modalButtonRow}>
                <TouchableOpacity style={styles.modalButton} onPress={handleRegisterTracker}>
                  <Text style={styles.modalButtonText}>Next</Text>
                </TouchableOpacity>
                <TouchableOpacity style={[styles.modalButton, styles.modalCancelButton]} onPress={() => setTrackerModalVisible(false)}>
                  <Text style={styles.modalButtonText1}>Cancel</Text>
                </TouchableOpacity>
              </View>
            </View>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
      {/* Add */}
      <Modal visible={dogProfileModalVisible} transparent animationType="slide">
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "height"}
          style={styles.modalBackground}
        >
          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            <View style={styles.modalContainer}>
              <Text style={styles.modalTitle}>Add Dog Profile</Text>
              <TextInput
                style={styles.input}
                placeholder="Name"
                value={newProfile.name}
                onChangeText={(text) => setNewProfile({ ...newProfile, name: text })}
              />
              <View style={styles.inputContainer}>
                <Picker
                  selectedValue={newProfile.breed}
                  onValueChange={(itemValue) => setNewProfile({ ...newProfile, breed: itemValue })}
                  style={styles.input}
                >
                    <Picker.Item label="Labrador Retriever" value="Labrador Retriever" style={styles.pickerItem} />
                    <Picker.Item label="German Shepherd" value="German Shepherd" style={styles.pickerItem} />
                    <Picker.Item label="Golden Retriever" value="Golden Retriever" style={styles.pickerItem} />
                    <Picker.Item label="Bulldog" value="Bulldog" style={styles.pickerItem} />
                    <Picker.Item label="Beagle" value="Beagle" style={styles.pickerItem} />
                    <Picker.Item label="Poodle" value="Poodle" style={styles.pickerItem} />
                    <Picker.Item label="Rottweiler" value="Rottweiler" style={styles.pickerItem} />
                    <Picker.Item label="Yorkshire Terrier" value="Yorkshire Terrier" style={styles.pickerItem} />
                    <Picker.Item label="Boxer" value="Boxer" style={styles.pickerItem} />
                    <Picker.Item label="Dachshund" value="Dachshund" style={styles.pickerItem} />
                    <Picker.Item label="Siberian Husky" value="Siberian Husky" style={styles.pickerItem} />
                    <Picker.Item label="Great Dane" value="Great Dane" style={styles.pickerItem} />
                    <Picker.Item label="Doberman Pinscher" value="Doberman Pinscher" style={styles.pickerItem} />
                    <Picker.Item label="Shih Tzu" value="Shih Tzu" style={styles.pickerItem} />
                    <Picker.Item label="Cocker Spaniel" value="Cocker Spaniel" style={styles.pickerItem} />
                    <Picker.Item label="Pug" value="Pug" style={styles.pickerItem} />
                    <Picker.Item label="Chihuahua" value="Chihuahua" style={styles.pickerItem} />
                    <Picker.Item label="Australian Shepherd" value="Australian Shepherd" style={styles.pickerItem} />
                    <Picker.Item label="Border Collie" value="Border Collie" style={styles.pickerItem} />
                    <Picker.Item label="French Bulldog" value="French Bulldog" style={styles.pickerItem} />
                    <Picker.Item label="Boston Terrier" value="Boston Terrier" style={styles.pickerItem} />
                    <Picker.Item label="Bichon Frise" value="Bichon Frise" style={styles.pickerItem} />
                    <Picker.Item label="Akita" value="Akita" style={styles.pickerItem} />
                    <Picker.Item label="Maltese" value="Maltese" style={styles.pickerItem} />
                    <Picker.Item label="Saint Bernard" value="Saint Bernard" style={styles.pickerItem} />
                    <Picker.Item label="Weimaraner" value="Weimaraner" style={styles.pickerItem} />
                    <Picker.Item label="Newfoundland" value="Newfoundland" style={styles.pickerItem} />
                    <Picker.Item label="Cavalier King Charles Spaniel" value="Cavalier King Charles Spaniel" style={styles.pickerItem} />
                    <Picker.Item label="Alaskan Malamute" value="Alaskan Malamute" style={styles.pickerItem} />
                    <Picker.Item label="Papillon" value="Papillon" style={styles.pickerItem} />
                    <Picker.Item label="Shar Pei" value="Shar Pei" style={styles.pickerItem} />
                    <Picker.Item label="Shiba Inu" value="Shiba Inu" style={styles.pickerItem} />
                    <Picker.Item label="Basenji" value="Basenji" style={styles.pickerItem} />
                    <Picker.Item label="Whippet" value="Whippet" style={styles.pickerItem} />
                    <Picker.Item label="Airedale Terrier" value="Airedale Terrier" style={styles.pickerItem} />
                    <Picker.Item label="Scottish Terrier" value="Scottish Terrier" style={styles.pickerItem} />
                    <Picker.Item label="Samoyed" value="Samoyed" style={styles.pickerItem} />
                    <Picker.Item label="Pekingese" value="Pekingese" style={styles.pickerItem} />
                    <Picker.Item label="Lhasa Apso" value="Lhasa Apso" style={styles.pickerItem} />
                    <Picker.Item label="Chow Chow" value="Chow Chow" style={styles.pickerItem} />
                    <Picker.Item label="Havanese" value="Havanese" style={styles.pickerItem} />
                    <Picker.Item label="Belgian Malinois" value="Belgian Malinois" style={styles.pickerItem} />
                    <Picker.Item label="Rhodesian Ridgeback" value="Rhodesian Ridgeback" style={styles.pickerItem} />
                    <Picker.Item label="Bernese Mountain Dog" value="Bernese Mountain Dog" style={styles.pickerItem} />

                </Picker>
              </View>
              <TextInput
                style={styles.input}
                placeholder="Age"
                value={newProfile.age}
                onChangeText={(text) => setNewProfile({ ...newProfile, age: text })}
              />
              <View style={styles.inputContainer}>
                <Picker
                  selectedValue={newProfile.gender}
                  onValueChange={(itemValue) => setNewProfile({ ...newProfile, gender: itemValue })}
                  style={styles.input}
                >
                  <Picker.Item label="Select Gender" value="" style={styles.pickerItem} />
                  <Picker.Item label="Male" value="Male" style={styles.pickerItem} />
                  <Picker.Item label="Female" value="Female" style={styles.pickerItem} />
                </Picker>
              </View>
              <TextInput
                style={styles.input}
                placeholder="Height"
                value={newProfile.height}
                onChangeText={(text) => setNewProfile({ ...newProfile, height: text })}
              />
              <TextInput
                style={styles.input}
                placeholder="Weight"
                value={newProfile.weight}
                onChangeText={(text) => setNewProfile({ ...newProfile, weight: text })}
              />

              <View style={styles.modalButtonRow}>
                <TouchableOpacity style={styles.modalButton} onPress={handleSaveDogProfile}>
                  <Text style={styles.modalButtonText}>Save</Text>
                </TouchableOpacity>
                <TouchableOpacity style={[styles.modalButton, styles.modalCancelButton]} onPress={() => setDogProfileModalVisible(false)}>
                  <Text style={styles.modalButtonText1}>Cancel</Text>
                </TouchableOpacity>
              </View>
            </View>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
      {/* Edit */}
      {renderEditModal()}

      {/* Delete Confirmation Modal */}
      <Modal
        visible={confirmDelete}
        animationType="fade"
        transparent={true}
        onRequestClose={handleDeleteCancel}
      >
        <View style={styles.modalBackground}>
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>Are you sure you want to delete this animal?</Text>
            <View style={styles.modalButtonRow}>
              <TouchableOpacity style={styles.modalButton} onPress={handleDelete}>
                <Text style={styles.modalButtonText}>Yes</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, styles.modalCancelButton]}
                onPress={handleDeleteCancel}
              >
                <Text style={styles.modalButtonText1}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Add lost status section before measurements */}
      {renderLostStatusSection()}

      {/* Add lost status modal */}
      {renderLostStatusModal()}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    paddingTop: 40,
    backgroundColor: colors.white,
  },
  scrollViewContent: {
    flexGrow: 1,
    justifyContent: 'center',
    width: '100%',
  },
  header: {
    alignItems: 'center',
    marginBottom: 13,
  },
  headerContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '80%',
    position: 'relative',
    paddingHorizontal: 20,
    alignItems: 'center',
  },
  imageContainer: {
    alignItems: 'center',
    width: 100,
    height: 100,
    borderRadius: 70,
    backgroundColor: colors.black,
  },
  profileImage: {
    width: '50%',
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    marginTop: 8,
  },
  buttonRow: {
    flexDirection: 'row',
    justifyContent: 'space-evenly',
    paddingHorizontal: 20,
    marginVertical: 10,
  },
  buttonColumn: {
    alignItems: 'center',
  },
  button: {
    backgroundColor: colors.yellow,
    padding: 10,
    borderRadius: 50,
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    borderColor: colors.black,
    borderWidth: 1,
  },
  buttonText: {
    color: colors.black,
    marginTop: 5,
    fontWeight: '600',
    textAlign: 'center',
  },
  profileDetails: {
    backgroundColor: colors.yellow,
    borderRadius: 10,
    padding: 16,
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
    borderColor: colors.grey,
    borderBottomWidth: 1,
  },
  label: {
    fontWeight: 'bold',
  },
  value: {
    color: colors.white,
  },
  modalBackground: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    backgroundColor: colors.white,
    width: '100%',
    maxWidth: 250,
    padding: 24,
    borderRadius: 12,
    alignItems: 'center',     // Centers everything horizontally
},

  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 20,
  },
  input: {
    height: 45,
    borderColor: colors.grey,
    borderWidth: 1,
    borderRadius: 5,
    paddingLeft: 10,
    paddingRight: 10,
    width: 200,
    fontSize: 14,
    marginBottom: 15,  // âœ… This adds spacing between all inputs
},

  picker: {
    height: 45,   // Same height as TextInput
    fontSize: 14,  // Make text size smaller
    width: 200,    // Match input width
    color: colors.black, // Optional to match text color
},

  inputContainer: {
    marginBottom: 12,
    borderColor: colors.grey,
    borderWidth: 1,
    borderRadius: 5,
  },
  pickerItem: {
    fontSize: 12,
    color: colors.grey,
  },
  modalButtonRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 20,
  },
  modalButton: {
    flex: 1,
    backgroundColor: colors.yellow,
    padding: 12,
    borderRadius: 10,
    marginHorizontal: 5,
    alignItems: 'center',
    borderColor: colors.black,
    borderWidth: 1,
  },
  modalCancelButton: {
    borderColor: colors.yellow,
    borderWidth: 1,
    backgroundColor: colors.black,
  },
  modalButtonText: {
    color: colors.black,
    fontWeight: '600',
    fontSize: 16,
    marginBottom: 2,
  },
  modalButtonText1: {
    color: colors.white,
    fontWeight: '600',
    fontSize: 16,
    marginBottom: 2,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  temperamentIndicator: {
    width: 15,
    height: 15,
    borderRadius: 7.5,
    marginRight: 5,
  },
  aggressiveIndicator: {
    backgroundColor: '#FF5252', // Red for aggressive
  },
  friendlyIndicator: {
    backgroundColor: '#4CAF50', // Green for friendly
  },
  neutralIndicator: {
    backgroundColor: colors.yellow, // Yellow for neutral
  },
  temperamentOptionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginVertical: 20,
    flexWrap: 'wrap',
  },
  temperamentOption: {
    alignItems: 'center',
    padding: 12,
    borderRadius: 10,
    borderWidth: 2,
    borderColor: '#eee',
    backgroundColor: '#f9f9f9',
    width: '30%',
    minWidth: 85,
    marginBottom: 10,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
  },
  selectedTemperament: {
    backgroundColor: colors.yellow,
    borderColor: colors.yellow,
  },
  temperamentText: {
    marginTop: 5,
    fontWeight: '600',
    color: '#333',
    fontSize: 12,
    textAlign: 'center',
  },
  selectedTemperamentText: {
    color: colors.white,
  },
  temperamentLabel: {
    fontSize: 16,
    fontWeight: '600',
    marginVertical: 12,
    color: colors.black,
  },
  modalContent: {
    backgroundColor: colors.white,
    padding: 20,
    borderRadius: 10,
    width: '90%',
    maxWidth: 350,
    alignSelf: 'center',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: colors.black,
  },
  saveButton: {
    backgroundColor: colors.yellow,
    padding: 14,
    borderRadius: 10,
    alignItems: 'center',
    marginTop: 10,
  },
  saveButtonText: {
    color: colors.black,
    fontWeight: '600',
    fontSize: 16,
  },
  temperamentBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    alignSelf: 'flex-start',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    marginBottom: 15,
    marginTop: 5,
  },
  temperamentBadgeText: {
    fontWeight: '600',
    fontSize: 14,
    marginLeft: 6,
  },
  aggressiveButton: {
    backgroundColor: colors.aggressive,
    borderColor: colors.aggressiveBorder,
  },
  friendlyButton: {
    backgroundColor: colors.friendly,
    borderColor: colors.friendlyBorder,
  },
  neutralButton: {
    backgroundColor: colors.neutral,
    borderColor: colors.neutralBorder,
  },
  aggressiveSaveButton: {
    backgroundColor: colors.aggressive,
    borderColor: colors.aggressiveBorder,
  },
  friendlySaveButton: {
    backgroundColor: colors.friendly,
    borderColor: colors.friendlyBorder,
  },
  selectedAggressiveOption: {
    backgroundColor: colors.aggressive,
    borderColor: colors.aggressiveBorder,
  },
  selectedFriendlyOption: {
    backgroundColor: colors.friendly,
    borderColor: colors.friendlyBorder,
  },
  recentlyChangedTemperament: {
    borderWidth: 2,
    borderColor: colors.warning,
    transform: [{ scale: 1.05 }]
  },
  statusMessage: {
    padding: 10,
    borderRadius: 5,
    marginTop: 10,
    alignItems: 'center'
  },
  statusMessageText: {
    color: 'white',
    fontWeight: 'bold'
  },
  recentlyChangedTemperament: {
    borderWidth: 2,
    borderColor: colors.warning,
    transform: [{ scale: 1.05 }]
  },
  section: {
    padding: 16,
    marginBottom: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  lostStatusContainer: {
    backgroundColor: colors.backgroundLight,
    borderRadius: 10,
    padding: 15,
    marginBottom: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2,
  },
  lostStatusActiveContainer: {
    backgroundColor: colors.aggressive + '20', // 20% opacity
    borderLeftWidth: 4,
    borderLeftColor: colors.aggressive,
  },
  lostStatusContent: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  lostStatusIcon: {
    marginRight: 10,
  },
  lostStatusTextContainer: {
    flex: 1,
  },
  lostStatusLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  lostStatusDescription: {
    fontSize: 14,
    color: colors.darkGray,
  },
  lostStatusButton: {
    backgroundColor: colors.aggressive,
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 16,
    alignItems: 'center',
    justifyContent: 'center',
    alignSelf: 'flex-start',
  },
  foundButton: {
    backgroundColor: colors.success,
  },
  lostStatusButtonText: {
    color: colors.white,
    fontWeight: 'bold',
    fontSize: 14,
  },
  lostModalBody: {
    alignItems: 'center',
    padding: 20,
  },
  lostModalIcon: {
    marginBottom: 15,
  },
  lostModalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
    textAlign: 'center',
  },
  lostModalDescription: {
    fontSize: 14,
    color: colors.darkGray,
    textAlign: 'center',
    marginBottom: 20,
  },
  lostModalButtonsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  lostModalButton: {
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 20,
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
    marginHorizontal: 5,
  },
  lostModalCancelButton: {
    backgroundColor: colors.lightGray,
  },
  lostModalLostButton: {
    backgroundColor: colors.aggressive,
  },
  lostModalFoundButton: {
    backgroundColor: colors.success,
  },
  lostModalDisabledButton: {
    backgroundColor: colors.lightGray,
    opacity: 0.6,
  },
  lostModalButtonText: {
    color: colors.white,
    fontWeight: 'bold',
    fontSize: 14,
  },
  warningBox: {
    flexDirection: 'row',
    backgroundColor: colors.warning + '20',
    borderRadius: 8,
    padding: 12,
    marginBottom: 20,
    alignItems: 'center',
  },
  warningIcon: {
    marginRight: 10,
  },
  warningText: {
    flex: 1,
    color: colors.darkGray,
    fontSize: 14,
  },
  closeButton: {
    padding: 5,
  },
  toggleContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    marginBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: colors.lightGray,
  },
  toggleLabelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  toggleIcon: {
    marginRight: 10,
  },
  toggleLabel: {
    fontSize: 16,
    color: colors.textPrimary,
  },
  warningBoxSmall: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: colors.warning + '20',
    borderRadius: 8,
    padding: 10,
    marginBottom: 16,
  },
  warningTextSmall: {
    fontSize: 12,
    color: colors.darkGray,
    marginLeft: 8,
    flex: 1,
  },
  editButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 15,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderTopColor: colors.lightGray,
  },
  cancelButton: {
    backgroundColor: colors.lightGray,
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 24,
    flex: 1,
    alignItems: 'center',
    marginRight: 10,
  },
  cancelButtonText: {
    color: colors.darkGray,
    fontWeight: 'bold',
    fontSize: 16,
  },
  editModalContent: {
    backgroundColor: '#fff',
    borderRadius: 10,
    width: '95%',
    maxWidth: 500,
    flex: 1,
    marginVertical: 40,
    overflow: 'hidden',
    alignSelf: 'center',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: colors.lightGray,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: colors.textPrimary,
  },
  closeButton: {
    padding: 5,
  },
  inputContainer: {
    marginBottom: 16,
  },
  inputLabel: {
    fontSize: 14,
    marginBottom: 6,
    color: colors.textPrimary,
  },
  input: {
    borderWidth: 1,
    borderColor: colors.lightGray,
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  editButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 15,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderTopColor: colors.lightGray,
  },
  saveButton: {
    backgroundColor: colors.yellow,
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 20,
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
    marginLeft: 8,
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
});

export default DogProfile;